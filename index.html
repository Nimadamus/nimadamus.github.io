<!-- FIX #3: EVEN MORE ROBUST AUTOMATION SCRIPT -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    const googleSheetUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTJHvgLVm48LPxFgZQvTca47OwpWQdqh2RANE2ZFhP67-Qb-cQXPUFJDZtUCnChIkwq5mxQNjYgAGMw/pub?output=csv';

    const recordDisplay = document.querySelector('#dash-record p');
    const freePickDisplay = document.querySelector('#dash-free-pick p');
    const tickerContent = document.getElementById('ticker-content');
    
    if (!recordDisplay || !freePickDisplay || !tickerContent) {
        console.error("Critical Error: Dashboard elements not found in HTML! Check your IDs: #dash-record p, #dash-free-pick p, #ticker-content.");
        return;
    }

    async function fetchAndProcessData() {
        try {
            const response = await fetch(googleSheetUrl + '&t=' + new Date().getTime()); // Appends a timestamp to bypass cache
            if (!response.ok) throw new Error('Network Error: Could not fetch Google Sheet. Check that it is published to the web.');
            
            const csvText = await response.text();
            if (!csvText) throw new Error('Data Error: Fetched sheet is empty.');

            const rows = csvText.trim().split(/\r?\n/);
            const headers = rows[0].split(',').map(h => h.trim());
            
            const allPicks = rows.slice(1).map(row => {
                const values = row.split(',');
                let entry = {};
                headers.forEach((header, i) => {
                    entry[header] = values[i] ? values[i].trim() : '';
                });
                return entry;
            }).filter(p => p.Pick);

            // --- 1. UPDATE VERIFIED RECORD ---
            let wins = 0, losses = 0, pushes = 0;
            allPicks.forEach(p => {
                // THIS IS THE FIX: Only count rows that actually have a grade.
                if (p.Grade) {
                    const grade = p.Grade.toUpperCase();
                    if (grade === 'W') wins++;
                    else if (grade === 'L') losses++;
                    else if (grade === 'P') pushes++;
                }
            });
            recordDisplay.textContent = `${wins}-${losses}-${pushes}`;

            // --- 2. UPDATE FREE DAILY PICK (most recent ungraded pick) ---
            const todaysPick = [...allPicks].reverse().find(p => !p.Grade);
            freePickDisplay.textContent = todaysPick ? `${todaysPick.Pick} (${todaysPick.Line})` : 'Check Back Soon!';

            // --- 3. UPDATE THE TICKER WITH LAST 3 DAYS OF *GRADED* PICKS ---
            const gradedPicks = allPicks.filter(p => p.Grade && p.Date);
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const lastThreeDaysPicks = gradedPicks.filter(p => {
                const pickDate = new Date(p.Date);
                if (isNaN(pickDate.getTime())) return false; // Skip invalid dates
                const diffTime = today.getTime() - pickDate.getTime();
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                return diffDays >= 0 && diffDays <= 3; // Graded picks from today, yesterday, 2 days ago, 3 days ago
            });
            
            if (lastThreeDaysPicks.length > 0) {
                let tickerHTML = '';
                const separator = ' <span class="ticker__separator">|||</span> ';
                lastThreeDaysPicks.sort((a,b) => new Date(b.Date) - new Date(a.Date)); // Sort newest first

                lastThreeDaysPicks.forEach((p, index) => {
                    const gradeClass = p.Grade.toUpperCase() === 'W' ? 'win' : 'loss';
                    const pickDate = new Date(p.Date);
                    const displayDate = `${pickDate.getMonth() + 1}/${pickDate.getDate()}`;
                    
                    tickerHTML += `<div class="ticker__item">${displayDate}: ${p.Pick} <span class="grade ${gradeClass}">${p.Grade}</span></div>`;
                    if (index < lastThreeDaysPicks.length - 1) {
                        tickerHTML += separator;
                    }
                });
                tickerContent.innerHTML = tickerHTML + separator + tickerHTML;
            } else {
                tickerContent.innerHTML = '<div class="ticker__item">No recent graded results to display.</div>';
            }

        } catch (error) {
            console.error('SCRIPT ERROR:', error);
            tickerContent.innerHTML = `<div class="ticker__item">Error: ${error.message}</div>`;
            recordDisplay.textContent = 'Error';
            freePickDisplay.textContent = 'Error';
        }
    }

    fetchAndProcessData();
});
</script>
