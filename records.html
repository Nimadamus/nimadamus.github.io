<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>BetLegend Complete Performance Records & Analytics Dashboard</title>
<meta content="Complete auto-updating betting performance analytics: ROI, units won, win percentage breakdown by sport, bet type, month, and confidence level. Live verified records dashboard." name="description"/>
<meta content="betting records, ROI tracker, sports betting analytics, unit tracking, win percentage, verified picks, bet type breakdown" name="keywords"/>
<link href="https://www.betlegendpicks.com/newlogo.png" rel="icon" type="image/png"/>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet"/>
<link href="https://www.betlegendpicks.com/records.html" rel="canonical"/>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<meta property="og:title" content="BetLegend Performance Records Dashboard">
<meta property="og:description" content="Live betting analytics with complete breakdowns by sport, bet type, month, and confidence level">
<meta property="og:url" content="https://www.betlegendpicks.com/records.html">
<meta property="og:type" content="website">
<meta property="og:image" content="https://www.betlegendpicks.com/newlogo.png">
<style>
:root {
    --primary: #0a0a0a;
    --secondary: #1a1a1a;
    --accent: #00e0ff;
    --gold: #FFD700;
    --green: #39FF14;
    --red: #FF3131;
    --text: #ffffff;
    --muted: #888;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
    font-family: 'Roboto', sans-serif;
    color: var(--text);
    line-height: 1.6;
    min-height: 100vh;

          padding-top: 140px;}

.header {
    background: linear-gradient(135deg, rgba(0, 224, 255, 0.1) 0%, rgba(255, 215, 0, 0.1) 100%);
    border-bottom: 2px solid var(--accent);
    padding: 40px 20px;
    text-align: center;
}

.header h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: 72px;
    font-weight: 900;
    color: var(--accent);
    text-shadow: 0 0 30px var(--accent);
    margin-bottom: 10px;
    letter-spacing: 2px;
}

.header .tagline {
    font-size: 18px;
    color: var(--gold);
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 3px;
}

.loading {
    text-align: center;
    padding: 100px 20px;
    font-size: 24px;
    color: var(--accent);
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 40px 20px;
}

.summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 25px;
    margin-bottom: 50px;
}

.stat-card {
    background: linear-gradient(135deg, rgba(26, 26, 26, 0.95) 0%, rgba(20, 20, 40, 0.95) 100%);
    border: 2px solid var(--accent);
    border-radius: 15px;
    padding: 30px;
    text-align: center;
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
}

.stat-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 40px rgba(0, 224, 255, 0.3);
    border-color: var(--gold);
}

.stat-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 5px;
    background: linear-gradient(90deg, var(--accent), var(--gold));
}

.stat-label {
    font-size: 14px;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 10px;
    font-weight: 500;
}

.stat-value {
    font-family: 'Orbitron', sans-serif;
    font-size: 62px;
    font-weight: 900;
    color: var(--accent);
    text-shadow: 0 0 20px var(--accent);
    line-height: 1;
}

.stat-value.positive {
    color: var(--green);
    text-shadow: 0 0 20px var(--green);
}

.stat-value.negative {
    color: var(--red);
    text-shadow: 0 0 20px var(--red);
}

.section {
    background: rgba(26, 26, 26, 0.6);
    border: 1px solid rgba(0, 224, 255, 0.3);
    border-radius: 15px;
    padding: 40px;
    margin-bottom: 40px;
    backdrop-filter: blur(10px);
}

.section-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 48px;
    font-weight: 700;
    color: var(--gold);
    margin-bottom: 30px;
    text-transform: uppercase;
    letter-spacing: 2px;
    display: flex;
    align-items: center;
    gap: 15px;
}

.section-title::before {
    content: '';
    width: 50px;
    height: 4px;
    background: linear-gradient(90deg, var(--accent), var(--gold));
    border-radius: 2px;
}

.table-container {
    overflow-x: auto;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}

thead {
    background: linear-gradient(135deg, rgba(0, 224, 255, 0.2) 0%, rgba(255, 215, 0, 0.2) 100%);
}

th {
    font-family: 'Orbitron', sans-serif;
    padding: 22px 20px;
    text-align: left;
    font-weight: 700;
    color: var(--accent);
    text-transform: uppercase;
    font-size: 18px;
    letter-spacing: 1px;
    border-bottom: 2px solid var(--accent);
}

td {
    padding: 22px 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    font-size: 20px;
}

tbody tr {
    transition: all 0.2s ease;
}

tbody tr:hover {
    background: rgba(0, 224, 255, 0.05);
}

.win {
    color: var(--green);
    font-weight: 700;
}

.loss {
    color: var(--red);
    font-weight: 700;
}

.badge {
    display: inline-block;
    padding: 6px 14px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.badge-nfl { background: rgba(255, 49, 49, 0.2); color: #FF3131; border: 1px solid #FF3131; }
.badge-nba { background: rgba(0, 224, 255, 0.2); color: var(--accent); border: 1px solid var(--accent); }
.badge-nhl { background: rgba(255, 215, 0, 0.2); color: var(--gold); border: 1px solid var(--gold); }
.badge-mlb { background: rgba(57, 255, 20, 0.2); color: var(--green); border: 1px solid var(--green); }
.badge-ncaaf { background: rgba(255, 105, 180, 0.2); color: #FF69B4; border: 1px solid #FF69B4; }
.badge-ncaab { background: rgba(255, 140, 0, 0.2); color: #FF8C00; border: 1px solid #FF8C00; }
.badge-soccer { background: rgba(148, 0, 211, 0.2); color: #9400D3; border: 1px solid #9400D3; }

.progress-bar {
    width: 100%;
    height: 8px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    overflow: hidden;
    margin-top: 8px;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), var(--green));
    border-radius: 10px;
    transition: width 0.5s ease;
}

.highlight-box {
    background: linear-gradient(135deg, rgba(57, 255, 20, 0.1) 0%, rgba(0, 224, 255, 0.1) 100%);
    border-left: 5px solid var(--green);
    padding: 25px;
    border-radius: 10px;
    margin: 30px 0;
}

.highlight-box h3 {
    font-family: 'Orbitron', sans-serif;
    color: var(--green);
    margin-bottom: 15px;
    font-size: 22px;
}

.footer-note {
    text-align: center;
    margin-top: 60px;
    padding: 30px;
    background: rgba(0, 224, 255, 0.05);
    border-radius: 10px;
    border: 1px solid rgba(0, 224, 255, 0.2);
    color: var(--muted);
    font-size: 14px;
}

.last-updated {
    text-align: center;
    font-size: 14px;
    color: var(--muted);
    margin-top: 20px;
    font-style: italic;
}

@media (max-width: 768px) {
    .header h1 {
        font-size: 32px;
    }

    .summary-grid {
        grid-template-columns: 1fr;
    }

    .section {
        padding: 25px;
    }

    .stat-value {
        font-size: 32px;
    }
}

/* Logo */
.logo-container {
    position: fixed;
    top: 20px;
    left: 40px;
    z-index: 1000;
}

.logo-container a {
    color: #fff;
    text-decoration: none;
    font-family: var(--font-primary);
    font-size: 2.5rem;
    font-weight: 900;
    text-transform: uppercase;
    text-shadow:
        0 0 10px rgba(255, 255, 255, 0.8),
        0 0 20px rgba(255, 255, 255, 0.4);
}

.logo-container span {
    color: var(--neon-cyan);
    text-shadow:
        0 0 15px rgba(0, 255, 255, 1),
        0 0 30px rgba(0, 255, 255, 0.8),
        0 0 50px rgba(0, 255, 255, 0.6);
}

/* Navigation */
.nav-links {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 18px;
    padding: 15px 5% 15px 5%;
    background: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(10px);
    border-bottom: 2px solid rgba(0, 224, 255, 0.3);
    z-index: 999;
    flex-wrap: wrap;
}

.nav-links a, .dropdown {
    display: inline-flex;
    align-items: center;
}

.nav-links a {
    font-family: var(--font-secondary);
    text-decoration: none;
    color: var(--text-color);
    font-weight: 600;
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 8px 10px;
    border-radius: 5px;
    transition: all 0.3s ease;
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
    white-space: nowrap;
}

.nav-links a:hover, .nav-links a.active {
    color: var(--neon-gold);
    text-shadow: 0 0 8px var(--neon-gold);
}

/* Dropdown */
.dropdown {
    position: relative;
    display: inline-flex;
    align-items: center;
}

.dropdown .dropbtn {
    font-family: var(--font-secondary);
    text-decoration: none;
    color: var(--text-color);
    font-weight: 600;
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 8px 10px;
    border-radius: 5px;
    transition: all 0.3s ease;
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
    background: none;
    border: none;
    cursor: pointer;
    white-space: nowrap;
    display: inline-flex;
    align-items: center;
}

.dropdown:hover .dropbtn {
    color: var(--neon-gold);
    text-shadow: 0 0 8px var(--neon-gold);
}

.dropdown-content {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    background: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(20px);
    min-width: 200px;
    box-shadow: 0px 8px 30px rgba(0, 224, 255, 0.4);
    z-index: 9999;
    border: 2px solid rgba(0, 224, 255, 0.5);
    border-radius: 10px;
    padding: 15px 0;
    margin-top: 10px;
}

.dropdown-content a {
    color: var(--neon-cyan);
    padding: 14px 20px;
    text-decoration: none;
    display: block;
    font-size: 0.95rem;
    text-align: left;
    transition: all 0.3s ease;
    text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
    border-left: 3px solid transparent;
}

.dropdown-content a:hover {
    background: linear-gradient(90deg, rgba(0, 224, 255, 0.3), rgba(0, 224, 255, 0.1));
    color: #fff;
    padding-left: 30px;
    text-shadow: 0 0 10px var(--glow-color);
    border-left-color: var(--neon-cyan);
}

/* Desktop only: show dropdown on hover */
@media (hover: hover) and (pointer: fine) {
    .dropdown:hover .dropdown-content {
        display: block;
        animation: dropdownFade 0.3s ease;
    }

    .dropdown:hover .dropbtn {
        color: var(--neon-gold);
        text-shadow: 0 0 15px var(--neon-gold), 0 2px 8px rgba(0, 0, 0, 0.8);
    }
}

/* Both desktop and mobile: show dropdown when active (clicked/tapped) */
.dropdown.active .dropdown-content {
    display: block;
    animation: dropdownFade 0.3s ease;
}

.dropdown.active .dropbtn {
    color: var(--neon-gold);
    text-shadow: 0 0 15px var(--neon-gold), 0 2px 8px rgba(0, 0, 0, 0.8);
}

@keyframes dropdownFade {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

@media (max-width: 768px) {
    body {
        padding-top: 120px !important;
    }

    .logo-container {
        top: 10px;
        left: 20px;
    }

    .logo-container a {
        font-size: 1.5rem;
    }

    .nav-links {
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
        padding: 10px 5px;
    }

    .nav-links a {
        font-size: 0.75rem;
        padding: 6px 10px;
    }

    .dropdown .dropbtn {
        font-size: 0.75rem;
        padding: 6px 10px;
    }

    .dropdown-content {
        min-width: 160px;
        padding: 10px 0;
    }

    .dropdown-content a {
        font-size: 0.85rem;
        padding: 12px 15px;
    min-height: 44px;
    display: flex;
    align-items: center;
    }
}

    </style>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-QS8L5TDNLY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-QS8L5TDNLY');
</script>

</head>
<body>

<!-- Logo -->
<div class="logo-container">
    <a href="index.html">BET<span>LEGEND</span></a>
</div>

<!-- Navigation -->
    <nav class="nav-links">
        <a href="handicapping-hub.html" style="background:linear-gradient(135deg,#ff6b00,#ff8c00);color:#fff;border-radius:8px;padding:8px 12px;">Hub</a>
        <a href="blog-page10.html">PICKS & ANALYSIS</a>

        <div class="dropdown">
            <button class="dropbtn">Records</button>
            <div class="dropdown-content">
                <a href="records.html">DETAILED BREAKDOWN</a>
                <a href="mlb-records.html">MLB</a>
                <a href="nfl-records.html">NFL</a>
                <a href="ncaaf-records.html">NCAAF</a>
                <a href="ncaab-records.html">NCAAB</a>
                <a href="nhl-records.html">NHL</a>
                <a href="nba-records.html">NBA</a>
                <a href="soccer-records.html">Soccer</a>
            </div>
        </div>

        <div class="dropdown">
            <button class="dropbtn">Sports</button>
            <div class="dropdown-content">
                <a href="nfl.html">NFL</a>
                <a href="mlb-page2.html">MLB</a>
                <a href="ncaaf.html">NCAAF</a>
                <a href="nba.html">NBA</a>
                <a href="ncaab.html">NCAAB</a>
                <a href="nhl.html">NHL</a>
                <a href="soccer.html">Soccer</a>
            </div>
        </div>

        <div class="dropdown">
            <button class="dropbtn">Resources</button>
            <div class="dropdown-content">
                <a href="live-odds.html">Live Odds</a>
                <a href="howitworks.html">How It Works</a>
                <a href="bankroll.html">Bankroll</a>
                <a href="kelly-criterion.html">Kelly Criterion</a>
                <a href="betting-calculators.html">Betting Calculators</a>
                <a href="screenshots.html">Screenshots</a>
                <a href="bestonlinesportsbook.html">Best Sportsbook</a>
                <a href="betting-glossary.html">Betting Glossary</a>
                <a href="betting-101.html">Betting 101</a>
                <a href="how-to-bet-mlb-totals.html">How to Bet MLB Totals</a>
            </div>
        </div>

        <a href="proofofpicks.html">Proof</a>
        <a href="news-page3.html">News</a>

        <div class="dropdown">
            <button class="dropbtn">Game of the Day</button>
            <div class="dropdown-content">
                <a href="featured-game-of-the-day-page12.html">Game of the Day</a>
                <a href="moneyline-parlay-of-the-day.html">ML Parlay of the Day</a>
            </div>
        </div>
    </nav>



<div class="header">
    <h1>üèÜ COMPLETE PERFORMANCE DASHBOARD</h1>
    <p class="tagline">Live-Updating Verified Records & Analytics</p>
</div>

<div id="loading-screen" class="loading">
    <p>üìä Loading all records from verified sources...</p>
    <p style="font-size: 16px; margin-top: 20px;">Aggregating NFL, NBA, NHL, MLB, NCAAF, NCAAB, and Soccer data...</p>
</div>

<div class="container" id="main-content" style="display: none;">

    <!-- SEO Content Section -->
    <div style="background: linear-gradient(135deg, rgba(26, 26, 26, 0.95) 0%, rgba(20, 20, 40, 0.95) 100%); border: 2px solid var(--accent); border-radius: 15px; padding: 30px; margin-bottom: 40px;">
        <h2 style="color: var(--gold); font-size: 28px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif;">Understanding Our Confidence-Based Unit System</h2>
        <p style="font-size: 16px; line-height: 1.8; margin-bottom: 15px;">
            At BetLegend, every sports betting pick is assigned a confidence rating from <strong style="color: var(--accent);">1 to 6</strong>, which directly determines the recommended unit sizing for optimal bankroll management. This systematic approach to bet sizing ensures that our most confident plays receive appropriate stake allocation while managing risk across the entire portfolio.
        </p>
        <p style="font-size: 16px; line-height: 1.8; margin-bottom: 15px;">
            Our <strong style="color: var(--gold);">confidence scale breakdown</strong> works as follows: <strong>Confidence 1</strong> represents small plays at <strong>0.5 units</strong>, ideal for speculative opportunities or contrarian positions. <strong>Confidence 2</strong> indicates standard plays at <strong>1 unit</strong>, which form the foundation of our betting portfolio. <strong>Confidence 3</strong> signals above-average conviction at <strong>1.5 units</strong>, reserved for favorable matchups with clear statistical edges.
        </p>
        <p style="font-size: 16px; line-height: 1.8; margin-bottom: 15px;">
            Moving up the confidence ladder, <strong style="color: var(--green);">Confidence 4</strong> represents strong plays at <strong>2 units</strong>, typically backed by multiple converging factors such as injury reports, weather conditions, and historical matchup data. <strong style="color: var(--gold);">Confidence 5</strong> indicates premium plays at <strong>2.5 units</strong>, where extensive research and analysis reveal significant value discrepancies in the betting market.
        </p>
        <p style="font-size: 16px; line-height: 1.8; margin-bottom: 0;">
            Finally, <strong style="color: var(--red);">Confidence 6 plays are our MAX BET selections at 3 units</strong>‚Äîthese represent the absolute highest conviction picks where we've identified exceptional value through comprehensive statistical modeling, situational analysis, and market inefficiencies. This tiered unit system allows bettors to scale their risk appropriately while maximizing returns on our most thoroughly researched picks across NFL, NBA, NHL, MLB, NCAAF, and Soccer betting markets.
        </p>
    </div>

    <!-- Overall Summary Cards -->
    <div class="summary-grid">
        <div class="stat-card">
            <div class="stat-label">Total Record</div>
            <div class="stat-value" id="total-record">--</div>
            <div class="progress-bar">
                <div class="progress-fill" id="win-progress" style="width: 0%;"></div>
            </div>
        </div>

        <div class="stat-card">
            <div class="stat-label">Win Rate</div>
            <div class="stat-value" id="win-rate">--</div>
        </div>

        <div class="stat-card">
            <div class="stat-label">Average Odds</div>
            <div class="stat-value" id="avg-odds">--</div>
        </div>

        <div class="stat-card">
            <div class="stat-label">Total Picks</div>
            <div class="stat-value" id="total-picks">--</div>
        </div>
    </div>

    <!-- Sport Breakdown -->
    <div class="section">
        <h2 class="section-title">üìä Breakdown by Sport</h2>
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Sport</th>
                        <th>Record</th>
                        <th>Win %</th>
                        <th>Units</th>
                        <th>ROI</th>
                        <th>Avg Odds</th>
                    </tr>
                </thead>
                <tbody id="sport-breakdown"></tbody>
            </table>
        </div>
    </div>

    <!-- Bet Type Breakdown -->
    <div class="section">
        <h2 class="section-title">üéØ Breakdown by Bet Type</h2>
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Bet Type</th>
                        <th>Record</th>
                        <th>Win %</th>
                        <th>Units</th>
                        <th>ROI</th>
                        <th>Best Sport</th>
                    </tr>
                </thead>
                <tbody id="bet-type-breakdown"></tbody>
            </table>
        </div>
    </div>

    <!-- Monthly Performance -->
    <div class="section">
        <h2 class="section-title">üìÖ Monthly Performance</h2>
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Month</th>
                        <th>Record</th>
                        <th>Win %</th>
                        <th>Units</th>
                        <th>ROI</th>
                        <th>Best Sport</th>
                    </tr>
                </thead>
                <tbody id="monthly-breakdown"></tbody>
            </table>
        </div>
    </div>

    <!-- Unit Sizing Breakdown -->
    <div class="section">
        <h2 class="section-title">üí∞ Unit Sizing & Confidence Levels</h2>
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Confidence</th>
                        <th># of Bets</th>
                        <th>Record</th>
                        <th>Win %</th>
                        <th>Total Units</th>
                        <th>ROI</th>
                    </tr>
                </thead>
                <tbody id="unit-sizing-breakdown"></tbody>
            </table>
        </div>

        <div class="highlight-box">
            <h3>üí° Bankroll Strategy</h3>
            <p>We use a <strong>flat unit betting system</strong> with scaled confidence sizing (0.5u to 3u). All records are auto-calculated from verified Google Sheets data.</p>
        </div>
    </div>

    <!-- Teaser Breakdown -->
    <div class="section">
        <h2 class="section-title">üé≤ Teaser Breakdown</h2>
        <div class="highlight-box" style="border-left-color: var(--gold);">
            <h3>What Are Teasers?</h3>
            <p style="margin-top: 10px; line-height: 1.8;">
                <strong>Teasers</strong> are a type of parlay bet that allows you to adjust the point spread or total in your favor across multiple games. In exchange for better lines, teasers pay out at lower odds than traditional parlays. Common teaser options include 6-point, 6.5-point, and 7-point teasers in football, and 4-point to 5-point teasers in basketball. This breakdown shows our performance on teaser bets compared to standard straight bets, helping you understand which betting style generates better returns.
            </p>
        </div>
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Category</th>
                        <th>Record</th>
                        <th>Win %</th>
                        <th>Units</th>
                        <th>ROI</th>
                        <th>Best Sport</th>
                    </tr>
                </thead>
                <tbody id="teaser-breakdown"></tbody>
            </table>
        </div>
    </div>

    <!-- Parlay Breakdown -->
    <div class="section">
        <h2 class="section-title">üé∞ Parlay Breakdown</h2>
        <div class="highlight-box" style="border-left-color: var(--accent);">
            <h3>What Are Parlays?</h3>
            <p style="margin-top: 10px; line-height: 1.8;">
                <strong>Parlays</strong> combine multiple bets into a single wager where all selections must win for the bet to pay out. Parlays offer higher potential payouts than individual bets, but come with increased risk since a single loss results in the entire parlay failing. Common parlay types include 2-leg, 3-leg, 4-leg, and larger multi-leg combinations across various sports and bet types. This breakdown shows our performance on parlay bets, helping you understand the risk-reward profile of combining multiple picks into parlays versus betting them individually.
            </p>
        </div>
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Parlay Type</th>
                        <th>Record</th>
                        <th>Win %</th>
                        <th>Units</th>
                        <th>ROI</th>
                        <th>Best Sport</th>
                    </tr>
                </thead>
                <tbody id="parlay-breakdown"></tbody>
            </table>
        </div>
        <div class="highlight-box" style="border-left-color: var(--green); margin-top: 20px;">
            <p style="margin: 0; line-height: 1.8;">
                <strong>Want to learn more about our moneyline parlay strategy?</strong> Read more about moneyline parlays <a href="moneyline-parlay-of-the-day.html" style="color: var(--accent); text-decoration: underline;">Here</a>
            </p>
        </div>
    </div>

    <!-- 5 Inning Breakdown -->
    <div class="section">
        <h2 class="section-title">‚öæ 5-Inning Bets Breakdown</h2>
        <div class="highlight-box" style="border-left-color: var(--green);">
            <h3>Why Bet First 5 Innings (F5)?</h3>
            <p style="margin-top: 10px; line-height: 1.8;">
                <strong>First 5 innings (F5) betting</strong> in baseball focuses exclusively on the starting pitcher matchup and early game performance, eliminating the bullpen variable that can make full-game bets unpredictable. F5 bets settle after 5 innings are complete, offering quicker results and more predictable outcomes based on starting pitcher analytics. This strategy is particularly effective when you have strong data on starter performance but less confidence in team bullpens. Our F5 breakdown shows performance across run lines, moneylines, and totals (over/under) specifically for the first 5 innings.
            </p>
        </div>
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Bet Type</th>
                        <th>Record</th>
                        <th>Win %</th>
                        <th>Units</th>
                        <th>ROI</th>
                        <th>Avg Odds</th>
                    </tr>
                </thead>
                <tbody id="five-inning-breakdown"></tbody>
            </table>
        </div>
    </div>

    <!-- Total Bets Breakdown -->
    <div class="section">
        <h2 class="section-title">üìä Total Bets (Over/Under) Breakdown</h2>
        <div class="highlight-box" style="border-left-color: var(--accent);">
            <h3>Mastering Over/Under Total Bets</h3>
            <p style="margin-top: 10px; line-height: 1.8;">
                <strong>Total bets (Over/Under)</strong> focus on the combined score of both teams rather than which team wins. You're betting whether the final combined score will be over or under the sportsbook's posted total. Total betting removes the need to predict a winner and instead focuses on game pace, offensive/defensive matchups, weather conditions, and playing style. This breakdown analyzes our performance on all totals combined, plus separate tracking for <strong>Over bets</strong> (expecting high-scoring games) versus <strong>Under bets</strong> (expecting defensive battles or low-scoring contests). Understanding your tendencies on overs vs unders can reveal valuable insights about betting biases and help optimize total bet selection across different sports.
            </p>
        </div>
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Category</th>
                        <th>Record</th>
                        <th>Win %</th>
                        <th>Units</th>
                        <th>ROI</th>
                        <th>Best Sport</th>
                    </tr>
                </thead>
                <tbody id="total-bets-breakdown"></tbody>
            </table>
        </div>
    </div>

    <!-- Team Totals by Sport -->
    <div class="section">
        <h2 class="section-title">üéØ Team Totals by Sport</h2>
        <div class="highlight-box" style="border-left-color: var(--gold);">
            <h3>What Are Team Totals?</h3>
            <p style="margin-top: 10px; line-height: 1.8;">
                <strong>Team Totals (TT)</strong> focus on a single team's scoring output rather than the combined total of both teams. You're betting whether one specific team will score over or under their posted team total. This removes the other team's performance from the equation and allows you to target teams with explosive offenses, strong defensive matchups, or favorable game scripts. Team totals are especially valuable when you have strong conviction about one team but uncertainty about their opponent.
            </p>
        </div>
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Sport</th>
                        <th>Record</th>
                        <th>Win %</th>
                        <th>Units</th>
                        <th>ROI</th>
                        <th>Avg Odds</th>
                    </tr>
                </thead>
                <tbody id="team-totals-by-sport"></tbody>
            </table>
        </div>
    </div>

    <!-- Methodology -->
    <div class="section">
        <h2 class="section-title">üß† Methodology & Data Source</h2>
        <div class="highlight-box" style="border-left-color: var(--accent);">
            <h3>How This Dashboard Works</h3>
            <ul style="margin-left: 20px; line-height: 2; margin-top: 15px;">
                <li><strong>Auto-updating:</strong> All data pulled live from verified Google Sheets</li>
                <li><strong>Complete transparency:</strong> Every pick tracked with date, result, and units</li>
                <li><strong>Calculated metrics:</strong> Win %, ROI, and breakdowns generated automatically</li>
                <li><strong>No manual editing:</strong> Numbers can't be fudged - direct from source</li>
            </ul>
        </div>
    </div>

    <div class="footer-note">
        <p><strong>üì¢ Records Disclaimer:</strong> Past performance does not guarantee future results. All data auto-generated from verified Google Sheets. Last refreshed on page load.</p>
        <p class="last-updated" id="last-updated">üïí Page loaded: <span id="load-time"></span></p>
        <p style="margin-top: 20px;">
            <a href="index.html" style="color: var(--accent); text-decoration: none; font-weight: 700;">‚Üê Back to Home</a> |
            <a href="upcomingpicks.html" style="color: var(--accent); text-decoration: none; font-weight: 700; margin-left: 20px;">View Upcoming Picks ‚Üí</a>
        </p>
    </div>

</div>

<script>
// Google Sheets CSV URLs for each sport
const SHEET_URLS = {
    'NFL': 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQgB4WcyyEpMBp_XI_ya6hC7Y8kRaHzrOvuLMq9voGF0nzfqi4lkmAWVb92nDkxUhLVhzr4RTWtZRxq/pub?output=csv',
    'NBA': 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSBoPl-dhj7ZAVpRIafqrFBf10r6sg3jpEKxmuymugAckdoMp-czkj1hscpDnV42GGJsIvNx5EniLVz/pub?output=csv',
    'NHL': 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRaRwsGOmbXrqAX0xqrDc9XwRCSaAOkuW68TArz3XQp7SMmLirKbdYqU5-zSM_A-MDNKG6sbdwZac6I/pub?output=csv',
    'MLB': 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQE9RjSNABgl0SxSA1ghp9soUs4gq7teoncN5GLmG5faXmH-sDwXgg0mrk0iQwmSEYExtx6xwFMflXv/pub?output=csv',
    'NCAAF': 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQ9c45xiuXWNe-fAXYMoNb00kCBHfMf4Yn-Xr2LUqdCIiuoiXXDgrDa5mq1PZqxjg8hx-5KnS0L4uVU/pub?output=csv',
    'NCAAB': 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQrFb66HE90gCwliIBQlZ5cNBApJWtGuUV1WbS4pd12SMrs_3qlmSFZCLJ9vBmfgZKcaaGyg4G15J3Y/pub?output=csv',
    'Soccer': 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQy0EQskvixsVQb1zzYtCKDa4F1Wl6WU5QuAFMit32vms-c4DxlhLik-k7U_EhuYntQrpw4BI6r0rns/pub?output=csv'
};

let allData = [];

async function fetchAllData() {
    const promises = Object.entries(SHEET_URLS).map(async ([sheetSport, url]) => {
        try {
            const response = await fetch(url);
            const csv = await response.text();
            const rows = parseCSV(csv);
            // Use the sport from the sheet name as fallback
            return rows.map(row => {
                // Fix ALL incorrect dates - force year to 2025 if it's wrong
                let dateStr = row.Date || row.date || '';
                if (dateStr) {
                    const date = new Date(dateStr);
                    if (!isNaN(date)) {
                        const year = date.getFullYear();
                        // Fix any year that's not 2025
                        if (year !== 2025) {
                            const correctedDate = new Date(2025, date.getMonth(), date.getDate());
                            row.Date = correctedDate.toISOString().split('T')[0];
                            row.date = row.Date;
                        }
                    }
                }
                return {
                    ...row,
                    sport: sheetSport // This maps to the correct sheet
                };
            });
        } catch (error) {
            console.error(`Error fetching ${sheetSport} data:`, error);
            return [];
        }
    });

    const results = await Promise.all(promises);
    const rawData = results.flat();
    console.log(`üì• Loaded ${rawData.length} total picks (before deduplication)`);

    // DEDUPLICATION: Remove duplicate bets by unique identifier (Date + Pick + Line)
    const seenBets = new Set();
    const duplicates = [];

    allData = rawData.filter(row => {
        // Create unique identifier from Date, Pick, and Line
        const dateStr = row.Date || row.date || '';
        const pick = (row.Pick || row.pick || '').trim();
        const line = (row.Line || row.line || '').trim();
        const sport = row.sport || '';

        const uniqueId = `${dateStr}|${sport}|${pick}|${line}`;

        if (seenBets.has(uniqueId)) {
            duplicates.push(row);
            return false; // Filter out duplicate
        }

        seenBets.add(uniqueId);
        return true; // Keep unique bet
    });

    console.log(`‚úÖ Loaded ${allData.length} unique picks (${duplicates.length} duplicates removed)`);
    if (duplicates.length > 0) {
        console.log(`üîÑ Duplicate bets removed:`, duplicates.slice(0, 5));
    }

    // Debug: Count entries by month
    const monthCounts = {};
    allData.forEach(row => {
        const date = new Date(row.Date || row.date || '');
        if (!isNaN(date)) {
            const key = date.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
            monthCounts[key] = (monthCounts[key] || 0) + 1;
        }
    });
    console.log('üìÖ Picks by month:', monthCounts);

    // Verify all dates are now 2025
    const non2025 = allData.filter(row => {
        const date = new Date(row.Date || row.date || '');
        return !isNaN(date) && date.getFullYear() !== 2025;
    });
    if (non2025.length > 0) {
        console.warn(`‚ö†Ô∏è WARNING: ${non2025.length} picks still have non-2025 dates!`);
    } else {
        console.log('‚úÖ All dates corrected to 2025');
    }
}

function parseCSV(csvText) {
    const lines = csvText.split('\n');
    const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
    const data = [];

    for (let i = 1; i < lines.length; i++) {
        if (lines[i].trim() === '') continue;

        const values = parseCSVLine(lines[i]);
        if (values.length >= headers.length) {
            const row = {};
            headers.forEach((header, index) => {
                row[header] = values[index] || '';
            });
            data.push(row);
        }
    }
    return data;
}

function parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;

    for (let i = 0; i < line.length; i++) {
        const char = line[i];

        if (char === '"') {
            inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
            result.push(current.trim());
            current = '';
        } else {
            current += char;
        }
    }
    result.push(current.trim());
    return result;
}

function calculateOverallStats() {
    // Use actual bet sizes for accurate ROI calculation
    const stats = calculateStats(allData, true);
    const totalPicks = stats.wins + stats.losses + stats.pushes;

    // Update display
    document.getElementById('total-record').textContent = stats.record;
    document.getElementById('win-rate').textContent = stats.winRate.toFixed(1) + '%';
    document.getElementById('win-rate').className = `stat-value ${stats.winRate >= 50 ? 'positive' : 'negative'}`;
    document.getElementById('avg-odds').textContent = stats.avgOdds > 0 ? '+' + stats.avgOdds : stats.avgOdds;
    document.getElementById('total-picks').textContent = totalPicks;
    document.getElementById('win-progress').style.width = stats.winRate + '%';
}

function calculateSportBreakdown() {
    const sports = ['NFL', 'NBA', 'NHL', 'MLB', 'NCAAF', 'NCAAB', 'Soccer'];
    const tbody = document.getElementById('sport-breakdown');
    tbody.innerHTML = '';

    sports.forEach(sport => {
        const sportData = allData.filter(row => row.sport === sport);
        if (sportData.length === 0) return;

        const stats = calculateStats(sportData, true);
        const row = document.createElement('tr');
        row.innerHTML = `
            <td><span class="badge badge-${sport.toLowerCase()}">${sport}</span></td>
            <td class="${stats.winRate >= 50 ? 'win' : 'loss'}">${stats.record}</td>
            <td class="${stats.winRate >= 50 ? 'win' : 'loss'}">${stats.winRate.toFixed(1)}%</td>
            <td class="${stats.units >= 0 ? 'win' : 'loss'}">${stats.units >= 0 ? '+' : ''}${stats.units.toFixed(1)}u</td>
            <td class="${stats.roi >= 0 ? 'win' : 'loss'}">${stats.roi >= 0 ? '+' : ''}${stats.roi.toFixed(1)}%</td>
            <td>${stats.avgOdds > 0 ? '+' : ''}${stats.avgOdds}</td>
        `;
        tbody.appendChild(row);
    });
}

function calculateBetTypeBreakdown() {
    const tbody = document.getElementById('bet-type-breakdown');
    tbody.innerHTML = '';

    // Track which bets have been categorized
    const categorizedIndices = new Set();
    const allBetTypes = [];

    // Filter bets by type in priority order (mutually exclusive)
    const betTypes = [
        { name: 'Teasers', filter: (pick) => pick.includes('teaser') || pick.includes('tsr') || pick.includes('teas') },
        { name: '5-Inning Bets', filter: (pick) => pick.includes('5 inn') || pick.includes('5-inn') || pick.includes('first 5') || pick.includes('f5') },
        { name: 'Over', filter: (pick) => pick.includes('over') },
        { name: 'Under', filter: (pick) => pick.includes('under') },
        { name: 'Moneyline', filter: (pick) => pick.includes('ml') || pick.includes('moneyline') },
        { name: 'Spread', filter: (pick) => (pick.includes('+') || pick.includes('-')) }
    ];

    // Categorize each bet type
    betTypes.forEach(betType => {
        const typeData = allData.filter((row, index) => {
            if (categorizedIndices.has(index)) return false; // Skip already categorized

            const result = (row.Result || row.result || '').toLowerCase().trim();
            if (!result || result === '' || result === 'pending') return false;

            const pick = (row.Pick || row.pick || '').toLowerCase();
            const betTypeCol = (row['Bet Type'] || row['bet type'] || row.BetType || row.betType || '').toLowerCase();
            const searchText = pick + ' ' + betTypeCol;

            if (betType.filter(searchText)) {
                categorizedIndices.add(index);
                return true;
            }
            return false;
        });

        if (typeData.length > 0) {
            allBetTypes.push({ name: betType.name, data: typeData });
        }
    });

    // Catch all uncategorized bets as "Other"
    const uncategorized = allData.filter((row, index) => {
        if (categorizedIndices.has(index)) return false;
        const result = (row.Result || row.result || '').toLowerCase().trim();
        return result && result !== '' && result !== 'pending';
    });

    if (uncategorized.length > 0) {
        allBetTypes.push({ name: 'Other', data: uncategorized });
        console.log('Uncategorized bets:', uncategorized.length, uncategorized);
    }

    // Display all bet types
    allBetTypes.forEach(betType => {
        const stats = calculateStats(betType.data, true);
        const row = document.createElement('tr');
        row.innerHTML = `
            <td><strong>${betType.name}</strong></td>
            <td class="${stats.winRate >= 50 ? 'win' : 'loss'}">${stats.record}</td>
            <td class="${stats.winRate >= 50 ? 'win' : 'loss'}">${stats.winRate.toFixed(1)}%</td>
            <td class="${stats.units >= 0 ? 'win' : 'loss'}">${stats.units >= 0 ? '+' : ''}${stats.units.toFixed(1)}u</td>
            <td class="${stats.roi >= 0 ? 'win' : 'loss'}">${stats.roi >= 0 ? '+' : ''}${stats.roi.toFixed(1)}%</td>
            <td>${findBestSport(betType.data)}</td>
        `;
        tbody.appendChild(row);
    });

    // Debug: Log total categorized vs total bets
    const totalCategorized = allBetTypes.reduce((sum, bt) => sum + bt.data.length, 0);
    const totalBets = allData.filter(row => {
        const result = (row.Result || row.result || '').toLowerCase().trim();
        return result && result !== '' && result !== 'pending';
    }).length;
    console.log(`Bet Type Breakdown: ${totalCategorized} categorized out of ${totalBets} total bets`);
}

function calculateMonthlyBreakdown() {
    const monthlyData = {};

    allData.forEach(row => {
        const dateStr = row.Date || row.date || '';
        const date = new Date(dateStr);
        if (isNaN(date)) return;

        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
        const monthName = date.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });

        if (!monthlyData[monthKey]) {
            monthlyData[monthKey] = { name: monthName, data: [], sortKey: monthKey };
        }
        monthlyData[monthKey].data.push(row);
    });

    const tbody = document.getElementById('monthly-breakdown');
    tbody.innerHTML = '';

    // Custom chronological sort order: May, June, July, August, September, October, November
    const customOrder = {
        '2025-05': 1,
        '2025-06': 2,
        '2025-07': 3,
        '2025-08': 4,
        '2025-09': 5,
        '2025-10': 6,
        '2025-11': 7
    };

    const sortedMonths = Object.values(monthlyData).sort((a, b) => {
        const orderA = customOrder[a.sortKey] || 999;
        const orderB = customOrder[b.sortKey] || 999;
        return orderA - orderB;
    });

    sortedMonths.forEach(month => {
        const stats = calculateStats(month.data, true);
        const bestSport = findBestSport(month.data);

        const row = document.createElement('tr');
        row.innerHTML = `
            <td><strong>${month.name}</strong></td>
            <td class="${stats.winRate >= 50 ? 'win' : 'loss'}">${stats.record}</td>
            <td class="${stats.winRate >= 50 ? 'win' : 'loss'}">${stats.winRate.toFixed(1)}%</td>
            <td class="${stats.units >= 0 ? 'win' : 'loss'}">${stats.units >= 0 ? '+' : ''}${stats.units.toFixed(1)}u</td>
            <td class="${stats.roi >= 0 ? 'win' : 'loss'}">${stats.roi >= 0 ? '+' : ''}${stats.roi.toFixed(1)}%</td>
            <td>${bestSport}</td>
        `;
        tbody.appendChild(row);
    });
}

function calculateUnitSizingBreakdown() {
    const confidenceLevels = [
        { name: 'üî• MAX PLAY (3u+)', min: 3, max: Infinity },
        { name: '‚≠ê HIGH (2u)', min: 2, max: 3 },
        { name: '‚úì STANDARD (1u)', min: 1, max: 2 },
        { name: 'üìâ SMALL (0.5u)', min: 0, max: 1 }
    ];

    const tbody = document.getElementById('unit-sizing-breakdown');
    tbody.innerHTML = '';

    let totalCategorized = 0;

    console.log('');
    console.log('3. QUERY AND FILTER LOGIC');
    console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');

    // First, test extractBetSize on all bets
    let extractedCount = 0, defaultedCount = 0;
    const betSizeDistribution = {};
    const halfUnitBets = [];
    const confidenceLevelDistribution = {};
    const missingConfidence = [];

    console.log('Stake Size Mapping:');
    console.log('  ‚Ä¢ Confidence 1 ‚Üí 0.5u (SMALL)');
    console.log('  ‚Ä¢ Confidence 2 ‚Üí 1.0u (STANDARD)');
    console.log('  ‚Ä¢ Confidence 3 ‚Üí 1.5u (STANDARD)');
    console.log('  ‚Ä¢ Confidence 4 ‚Üí 2.0u (HIGH)');
    console.log('  ‚Ä¢ Confidence 5 ‚Üí 2.5u (HIGH)');
    console.log('  ‚Ä¢ Confidence 6 ‚Üí 3.0u (MAX PLAY)');
    console.log('');

    allData.forEach(row => {
        const result = (row.Result || row.result || '').toLowerCase();
        if (!result || result === '' || result === 'pending') return;

        const pick = (row.Pick || row.pick || '').toLowerCase();
        const betType = (row['Bet Type'] || row['bet type'] || '').toLowerCase();
        const confidence = row.Confidence || row.confidence || '';
        const searchText = pick + ' ' + betType;
        const unitMatch = searchText.match(/(\d+\.?\d*)\s*u(?!n)/i);
        const betSize = extractBetSize(row);

        // Track confidence level distribution
        if (confidence) {
            confidenceLevelDistribution[confidence] = (confidenceLevelDistribution[confidence] || 0) + 1;
        } else {
            missingConfidence.push({
                sport: row.sport,
                pick: pick.substring(0, 30),
                result: result,
                units: row.Units || row.units
            });
        }

        if (unitMatch) {
            extractedCount++;
        } else {
            defaultedCount++;
            if (defaultedCount <= 3) {
                console.log(`  Defaulted: "${pick.substring(0, 30)}..." (Conf: ${confidence || 'MISSING'}) -> ${betSize}u`);
            }
        }

        betSizeDistribution[betSize] = (betSizeDistribution[betSize] || 0) + 1;

        // Track 0.5u bets specifically
        if (betSize === 0.5) {
            halfUnitBets.push({
                pick: pick.substring(0, 30),
                result: result,
                confidence: confidence || 'MISSING',
                betSize: betSize
            });
        }
    });

    console.log('Bet Size Extraction Results:');
    console.log(`  ‚Ä¢ Extracted from Pick/BetType text: ${extractedCount} bets`);
    console.log(`  ‚Ä¢ Defaulted (using confidence or fallback): ${defaultedCount} bets`);
    console.log('');
    console.log('Confidence Level Distribution (from Sheets):');
    Object.keys(confidenceLevelDistribution).sort().forEach(conf => {
        console.log(`  ‚Ä¢ Confidence ${conf}: ${confidenceLevelDistribution[conf]} bets`);
    });
    if (missingConfidence.length > 0) {
        console.log(`  ‚ö†Ô∏è MISSING Confidence: ${missingConfidence.length} bets`);
        console.log('    Sample bets with missing confidence:', missingConfidence.slice(0, 3));
    }
    console.log('');
    console.log('Extracted Bet Size Distribution:');
    Object.keys(betSizeDistribution).sort((a,b) => parseFloat(a) - parseFloat(b)).forEach(size => {
        console.log(`  ‚Ä¢ ${size}u: ${betSizeDistribution[size]} bets`);
    });
    console.log('');
    console.log(`Pushes Handling: Excluded from Win% denominator, included in record format only`);
    console.log('---');

    console.log('');
    console.log('4. FORMULA VERIFICATION BY CONFIDENCE BUCKET');
    console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');

    confidenceLevels.forEach(level => {
        const levelData = allData.filter(row => {
            const result = (row.Result || row.result || '').toLowerCase();
            // Only include bets with results (exclude pending)
            if (!result || result === '' || result === 'pending') {
                return false;
            }
            // Extract the ACTUAL bet size from the pick text, not the profit/loss
            const betSize = extractBetSize(row);
            // Use >= for min to include boundary values
            return betSize >= level.min && (level.max === Infinity ? true : betSize < level.max);
        });

        if (levelData.length === 0) {
            console.log(`${level.name}:`);
            console.log(`  ‚ö†Ô∏è NO DATA - 0 bets in range ${level.min}u to ${level.max === Infinity ? '‚àû' : level.max}u`);
            console.log('');
            return;
        }

        totalCategorized += levelData.length;
        const stats = calculateStats(levelData, true); // Use actual bet sizes
        const avgBetSize = levelData.length > 0 ? stats.totalRisked / levelData.length : 0;

        console.log(`${level.name} (${level.min}u ‚â§ bet < ${level.max === Infinity ? '‚àû' : level.max}u):`);
        console.log(`  Row Count: ${levelData.length} bets`);
        console.log(`  Wins: ${stats.wins}, Losses: ${stats.losses}, Pushes: ${stats.pushes}`);
        console.log(`  Record: ${stats.record}`);
        console.log(`  Win% Formula: ${stats.wins} / (${stats.wins} + ${stats.losses}) = ${stats.winRate.toFixed(2)}%`);
        console.log(`  Total Units: ${stats.units.toFixed(2)}u (sum of all units won/lost)`);
        console.log(`  Total Risked: ${stats.totalRisked.toFixed(2)}u`);
        console.log(`  ROI Formula: ${stats.units.toFixed(2)} / ${stats.totalRisked.toFixed(2)} = ${stats.roi.toFixed(2)}%`);
        console.log(`  Avg Bet Size: ${avgBetSize.toFixed(2)}u`);

        // Validation checks
        const hasZeroDenominator = (stats.wins + stats.losses) === 0;
        const hasNullMetric = isNaN(stats.winRate) || isNaN(stats.roi) || isNaN(stats.units);

        if (hasZeroDenominator) {
            console.log(`  ‚ùå VALIDATION ERROR: Zero denominator (no wins or losses)`);
        }
        if (hasNullMetric) {
            console.log(`  ‚ùå VALIDATION ERROR: Null metric detected`);
        }
        if (!hasZeroDenominator && !hasNullMetric) {
            console.log(`  ‚úÖ VALIDATION PASSED`);
        }

        // Sample some bets
        if (levelData.length > 0) {
            const samples = levelData.slice(0, 2).map(row => {
                const betSize = extractBetSize(row);
                const result = row.Result || row.result;
                const units = row.Units || row.units;
                const pick = (row.Pick || row.pick || '').substring(0, 25);
                return `[${betSize}u] "${pick}" = ${result} (${units}u)`;
            });
            console.log(`  Sample: ${samples.join('; ')}`);
        }
        console.log('');

        const row = document.createElement('tr');
        row.innerHTML = `
            <td><strong>${level.name}</strong></td>
            <td>${levelData.length}</td>
            <td class="${stats.winRate >= 50 ? 'win' : 'loss'}">${stats.record}</td>
            <td class="${stats.winRate >= 50 ? 'win' : 'loss'}">${stats.winRate.toFixed(1)}%</td>
            <td class="${stats.units >= 0 ? 'win' : 'loss'}">${stats.units >= 0 ? '+' : ''}${stats.units.toFixed(2)}u</td>
            <td class="${stats.roi >= 0 ? 'win' : 'loss'}">${stats.roi >= 0 ? '+' : ''}${stats.roi.toFixed(2)}%</td>
        `;
        tbody.appendChild(row);
    });

    console.log(`Total Categorized: ${totalCategorized} bets`);
    console.log('===================================');
}

function calculateStats(data, useActualBetSizes = false) {
    let wins = 0, losses = 0, pushes = 0;
    let totalUnits = 0;
    let totalOdds = 0, oddsCount = 0;
    let totalRisked = 0;

    // Process each row
    data.forEach(row => {
        const result = (row.Result || row.result || '').toLowerCase().trim();
        const units = parseFloat(row.Units || row.units || 0);
        const line = row.Line || row.line || row.Odds || row.odds || '';

        // Skip pending or empty results
        if (!result || result === '' || result === 'pending') {
            return;
        }

        // Get the actual bet size for accurate ROI
        const betSize = useActualBetSizes ? extractBetSize(row) : 1;
        totalRisked += betSize;

        // Count wins, losses, pushes - EXACT MATCH to betlegend-verified-records.html logic
        const resultUpper = result.toUpperCase();
        if (resultUpper === 'W' || resultUpper === 'WIN') {
            wins++;
            totalUnits += units; // Add units as-is (should be positive for wins)
        } else if (resultUpper === 'L' || resultUpper === 'LOSS') {
            losses++;
            totalUnits += units; // Add units as-is (should be negative for losses)
        } else if (resultUpper === 'P' || resultUpper === 'PUSH') {
            pushes++;
            // Pushes are 0 profit/loss, but still risked capital
        }

        // Track odds - ONLY for straight bets (exclude parlays/teasers) but INCLUDE pushes
        const pick = (row.Pick || row.pick || '').toLowerCase();
        const betType = (row['Bet Type'] || row['bet type'] || row.BetType || row.betType || '').toLowerCase();
        const searchText = pick + ' ' + betType;

        // Exclude parlays and teasers from odds calculation
        const isParlay = searchText.includes('parlay');
        const isTeaser = searchText.includes('teaser');

        if (!isParlay && !isTeaser) {
            const odds = extractOdds(line);
            if (odds) {
                totalOdds += odds;
                oddsCount++;
            }
        }
    });

    // Calculate totals
    const totalBets = wins + losses; // Pushes don't count in win rate
    const winRate = totalBets > 0 ? (wins / totalBets) * 100 : 0;

    // ROI = profit / total risked
    const roi = totalRisked > 0 ? (totalUnits / totalRisked) * 100 : 0;

    const avgOdds = oddsCount > 0 ? Math.round(totalOdds / oddsCount) : -110;

    return {
        record: `${wins}-${losses}${pushes > 0 ? `-${pushes}` : ''}`,
        wins,
        losses,
        pushes,
        winRate,
        units: totalUnits,
        roi,
        avgOdds,
        totalRisked
    };
}

function findBestSport(data) {
    const sports = ['NFL', 'NBA', 'NHL', 'MLB', 'NCAAF', 'NCAAB', 'Soccer'];
    let bestSport = '';
    let bestWinRate = 0;

    sports.forEach(sport => {
        const sportData = data.filter(row => row.sport === sport);
        if (sportData.length === 0) return;

        const stats = calculateStats(sportData, true);
        if (stats.winRate > bestWinRate) {
            bestWinRate = stats.winRate;
            bestSport = `${sport} (${stats.winRate.toFixed(1)}%)`;
        }
    });

    return bestSport || 'N/A';
}

function calculateTeaserBreakdown() {
    const tbody = document.getElementById('teaser-breakdown');
    tbody.innerHTML = '';

    // First, get ALL teasers using EXACT same logic as Bet Type Breakdown
    const allTeasersData = allData.filter(row => {
        const result = (row.Result || row.result || '').toLowerCase().trim();
        if (!result || result === '' || result === 'pending') return false;

        const pick = (row.Pick || row.pick || '').toLowerCase();
        const betTypeCol = (row['Bet Type'] || row['bet type'] || row.BetType || row.betType || '').toLowerCase();
        const searchText = pick + ' ' + betTypeCol;

        // EXACT same filter as Bet Type Breakdown line 1089
        return searchText.includes('teaser') || searchText.includes('tsr') || searchText.includes('teas');
    });

    // Add Total Teasers row first
    if (allTeasersData.length > 0) {
        const totalStats = calculateStats(allTeasersData, true);
        const totalRow = document.createElement('tr');
        totalRow.style.fontWeight = 'bold';
        totalRow.style.backgroundColor = 'rgba(0, 224, 255, 0.1)';
        totalRow.innerHTML = `
            <td><strong>üìä TOTAL TEASERS</strong></td>
            <td class="${totalStats.winRate > 50 ? 'win' : 'loss'}">${totalStats.record}</td>
            <td class="${totalStats.winRate > 50 ? 'win' : ''}">${totalStats.winRate.toFixed(1)}%</td>
            <td class="${totalStats.units >= 0 ? 'win' : 'loss'}">${totalStats.units >= 0 ? '+' : ''}${totalStats.units.toFixed(1)}u</td>
            <td class="${totalStats.roi >= 0 ? 'win' : 'loss'}">${totalStats.roi >= 0 ? '+' : ''}${totalStats.roi.toFixed(1)}%</td>
            <td>${findBestSport(allTeasersData)}</td>
        `;
        tbody.appendChild(totalRow);
    }

    // Define specific teaser types - match "6 point", "6pt", "6.5 point", "7 point" etc.
    const teaserTypes = [
        { name: '6.5-Point Teaser', pattern: /(6\.5|6\s*1\/2)\s*-?\s*p/i },     // "6.5 point" or "6 1/2 pt"
        { name: '6-Point Teaser', pattern: /\b6(?!\.5|\s*1\/2)\s*-?\s*p/i },    // "6 point" but NOT "6.5" or "6 1/2"
        { name: '7-Point Teaser', pattern: /\b7\s*-?\s*p/i }                     // "7 point" or "7pt"
    ];

    let hasData = allTeasersData.length > 0;

    teaserTypes.forEach(teaserType => {
        const typeData = allTeasersData.filter(row => {
            const pick = (row.Pick || row.pick || '').toLowerCase();
            const betType = (row['Bet Type'] || row['bet type'] || row.BetType || row.betType || '').toLowerCase();
            const searchText = pick + ' ' + betType;

            // Match the point value pattern
            return teaserType.pattern.test(searchText);
        });

        if (typeData.length === 0) return;

        hasData = true;
        const stats = calculateStats(typeData, true);
        const row = document.createElement('tr');
        row.innerHTML = `
            <td><strong>${teaserType.name}</strong></td>
            <td class="${stats.winRate > 50 ? 'win' : 'loss'}">${stats.record}</td>
            <td class="${stats.winRate > 50 ? 'win' : ''}">${stats.winRate.toFixed(1)}%</td>
            <td class="${stats.units >= 0 ? 'win' : 'loss'}">${stats.units >= 0 ? '+' : ''}${stats.units.toFixed(1)}u</td>
            <td class="${stats.roi >= 0 ? 'win' : 'loss'}">${stats.roi >= 0 ? '+' : ''}${stats.roi.toFixed(1)}%</td>
            <td>${findBestSport(typeData)}</td>
        `;
        tbody.appendChild(row);
    });

    if (!hasData) {
        tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--muted);">No teaser data available</td></tr>';
    }
}

function calculateParlayBreakdown() {
    const tbody = document.getElementById('parlay-breakdown');
    tbody.innerHTML = '';

    // Define specific parlay types to show - matching "X team parlay" or "X leg parlay" format
    const parlayTypes = [
        { name: '2-Team Parlay', pattern: '2' },
        { name: '3-Team Parlay', pattern: '3' },
        { name: '4-Team Parlay', pattern: '4' },
        { name: '5-Team Parlay', pattern: '5' },
        { name: '6-Team Parlay', pattern: '6' },
        { name: '7+ Team Parlay', patterns: ['7', '8', '9', '10'] }
    ];

    let hasData = false;

    parlayTypes.forEach(parlayType => {
        const typeData = allData.filter(row => {
            const pick = (row.Pick || row.pick || '').toLowerCase();
            const betType = (row['Bet Type'] || row['bet type'] || row.BetType || row.betType || '').toLowerCase();
            const searchText = pick + ' ' + betType;

            // Check if it's a parlay (including abbreviations)
            const isParlayBet = searchText.includes('parlay') || searchText.includes('parl');
            if (!isParlayBet) return false;

            // Match the team/leg count (e.g., "2 team", "2team", "2 leg", "2leg")
            if (parlayType.patterns) {
                // For 7+ Team Parlay, check multiple patterns
                return parlayType.patterns.some(pattern => {
                    const teamPattern = new RegExp(pattern + '\\s*(team|leg)', 'i');
                    return teamPattern.test(searchText);
                });
            } else {
                // For single pattern (2-6 team parlays)
                const teamPattern = new RegExp(parlayType.pattern + '\\s*(team|leg)', 'i');
                return teamPattern.test(searchText);
            }
        });

        if (typeData.length === 0) return;

        hasData = true;
        const stats = calculateStats(typeData, true);
        const row = document.createElement('tr');
        row.innerHTML = `
            <td><strong>${parlayType.name}</strong></td>
            <td class="${stats.winRate > 50 ? 'win' : 'loss'}">${stats.record}</td>
            <td class="${stats.winRate > 50 ? 'win' : ''}">${stats.winRate.toFixed(1)}%</td>
            <td class="${stats.units >= 0 ? 'win' : 'loss'}">${stats.units >= 0 ? '+' : ''}${stats.units.toFixed(1)}u</td>
            <td class="${stats.roi >= 0 ? 'win' : 'loss'}">${stats.roi >= 0 ? '+' : ''}${stats.roi.toFixed(1)}%</td>
            <td>${findBestSport(typeData)}</td>
        `;
        tbody.appendChild(row);
    });

    if (!hasData) {
        tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--muted);">No parlay data available</td></tr>';
    }
}

function calculateFiveInningBreakdown() {
    const fiveInningData = allData.filter(row => {
        const pick = (row.Pick || row.pick || '').toLowerCase();
        const betType = (row['Bet Type'] || row['bet type'] || row.BetType || row.betType || '').toLowerCase();
        const searchText = pick + ' ' + betType;
        return searchText.includes('5 inn') || searchText.includes('5-inn') || searchText.includes('first 5') || searchText.includes('f5');
    });

    console.log(`5-Inning Breakdown - Found ${fiveInningData.length} five-inning bets`);
    if (fiveInningData.length > 0) {
        console.log('Sample 5-inning bet:', fiveInningData[0]);
    }

    const tbody = document.getElementById('five-inning-breakdown');
    tbody.innerHTML = '';

    if (fiveInningData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--muted);">No 5-inning data available</td></tr>';
        return;
    }

    // Break down by bet type
    const betTypes = [
        { name: 'Spread/Run Line', filter: (pick) => (pick.includes('+') || pick.includes('-')) && !pick.includes('over') && !pick.includes('under') && !pick.includes('ml') && !pick.includes('moneyline') },
        { name: 'Moneyline', filter: (pick) => pick.includes('ml') || pick.includes('moneyline') },
        { name: 'Over', filter: (pick) => pick.includes('over') },
        { name: 'Under', filter: (pick) => pick.includes('under') }
    ];

    betTypes.forEach(betType => {
        const typeData = fiveInningData.filter(row => {
            const pick = (row.Pick || row.pick || '').toLowerCase();
            return betType.filter(pick);
        });

        if (typeData.length === 0) return;

        const stats = calculateStats(typeData, true);
        const row = document.createElement('tr');
        row.innerHTML = `
            <td><strong>${betType.name}</strong></td>
            <td class="${stats.winRate > 50 ? 'win' : 'loss'}">${stats.record}</td>
            <td class="${stats.winRate > 50 ? 'win' : ''}">${stats.winRate.toFixed(1)}%</td>
            <td class="${stats.units >= 0 ? 'win' : 'loss'}">${stats.units >= 0 ? '+' : ''}${stats.units.toFixed(1)}u</td>
            <td class="${stats.roi >= 0 ? 'win' : 'loss'}">${stats.roi >= 0 ? '+' : ''}${stats.roi.toFixed(1)}%</td>
            <td>${stats.avgOdds > 0 ? '+' : ''}${stats.avgOdds}</td>
        `;
        tbody.appendChild(row);
    });
}

function calculateTotalBetsBreakdown() {
    // Filter for all Over/Under total bets
    const totalBetsData = allData.filter(row => {
        const pick = (row.Pick || row.pick || '').toLowerCase();
        const betType = (row['Bet Type'] || row['bet type'] || row.BetType || row.betType || '').toLowerCase();
        const searchText = pick + ' ' + betType;
        return searchText.includes('over') || searchText.includes('under') || searchText.includes('total');
    });

    console.log(`Total Bets Breakdown - Found ${totalBetsData.length} total bets (over/under)`);
    if (totalBetsData.length > 0) {
        console.log('Sample total bet:', totalBetsData[0]);
    }

    const tbody = document.getElementById('total-bets-breakdown');
    tbody.innerHTML = '';

    if (totalBetsData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--muted);">No total bets data available</td></tr>';
        return;
    }

    // Overall Totals
    const allTotalsStats = calculateStats(totalBetsData, true);
    let row = document.createElement('tr');
    row.innerHTML = `
        <td><strong>All Total Bets</strong></td>
        <td class="${allTotalsStats.winRate > 50 ? 'win' : 'loss'}">${allTotalsStats.record}</td>
        <td class="${allTotalsStats.winRate > 50 ? 'win' : ''}">${allTotalsStats.winRate.toFixed(1)}%</td>
        <td class="${allTotalsStats.units >= 0 ? 'win' : 'loss'}">${allTotalsStats.units >= 0 ? '+' : ''}${allTotalsStats.units.toFixed(1)}u</td>
        <td class="${allTotalsStats.roi >= 0 ? 'win' : 'loss'}">${allTotalsStats.roi >= 0 ? '+' : ''}${allTotalsStats.roi.toFixed(1)}%</td>
        <td>${findBestSport(totalBetsData)}</td>
    `;
    tbody.appendChild(row);

    // Over bets
    const overData = totalBetsData.filter(row => {
        const pick = (row.Pick || row.pick || '').toLowerCase();
        return pick.includes('over');
    });

    if (overData.length > 0) {
        const overStats = calculateStats(overData, true);
        row = document.createElement('tr');
        row.innerHTML = `
            <td><strong>Over Bets</strong></td>
            <td class="${overStats.winRate > 50 ? 'win' : 'loss'}">${overStats.record}</td>
            <td class="${overStats.winRate > 50 ? 'win' : ''}">${overStats.winRate.toFixed(1)}%</td>
            <td class="${overStats.units >= 0 ? 'win' : 'loss'}">${overStats.units >= 0 ? '+' : ''}${overStats.units.toFixed(1)}u</td>
            <td class="${overStats.roi >= 0 ? 'win' : 'loss'}">${overStats.roi >= 0 ? '+' : ''}${overStats.roi.toFixed(1)}%</td>
            <td>${findBestSport(overData)}</td>
        `;
        tbody.appendChild(row);
    }

    // Under bets
    const underData = totalBetsData.filter(row => {
        const pick = (row.Pick || row.pick || '').toLowerCase();
        return pick.includes('under');
    });

    if (underData.length > 0) {
        const underStats = calculateStats(underData, true);
        row = document.createElement('tr');
        row.innerHTML = `
            <td><strong>Under Bets</strong></td>
            <td class="${underStats.winRate > 50 ? 'win' : 'loss'}">${underStats.record}</td>
            <td class="${underStats.winRate > 50 ? 'win' : ''}">${underStats.winRate.toFixed(1)}%</td>
            <td class="${underStats.units >= 0 ? 'win' : 'loss'}">${underStats.units >= 0 ? '+' : ''}${underStats.units.toFixed(1)}u</td>
            <td class="${underStats.roi >= 0 ? 'win' : 'loss'}">${underStats.roi >= 0 ? '+' : ''}${underStats.roi.toFixed(1)}%</td>
            <td>${findBestSport(underData)}</td>
        `;
        tbody.appendChild(row);
    }

    // Team Totals (only match "team total", not "tt" which catches Seattle, Pittsburgh, etc.)
    const teamTotalData = totalBetsData.filter(row => {
        const pick = (row.Pick || row.pick || '').toLowerCase();
        const betType = (row['Bet Type'] || row['bet type'] || row.BetType || row.betType || '').toLowerCase();
        const searchText = pick + ' ' + betType;
        return searchText.includes('team total');
    });

    if (teamTotalData.length > 0) {
        const ttStats = calculateStats(teamTotalData, true);
        row = document.createElement('tr');
        row.innerHTML = `
            <td><strong>Team Totals</strong></td>
            <td class="${ttStats.winRate > 50 ? 'win' : 'loss'}">${ttStats.record}</td>
            <td class="${ttStats.winRate > 50 ? 'win' : ''}">${ttStats.winRate.toFixed(1)}%</td>
            <td class="${ttStats.units >= 0 ? 'win' : 'loss'}">${ttStats.units >= 0 ? '+' : ''}${ttStats.units.toFixed(1)}u</td>
            <td class="${ttStats.roi >= 0 ? 'win' : 'loss'}">${ttStats.roi >= 0 ? '+' : ''}${ttStats.roi.toFixed(1)}%</td>
            <td>${findBestSport(teamTotalData)}</td>
        `;
        tbody.appendChild(row);
    }

    // Game Totals (non-team totals)
    const gameTotalData = totalBetsData.filter(row => {
        const pick = (row.Pick || row.pick || '').toLowerCase();
        const betType = (row['Bet Type'] || row['bet type'] || row.BetType || row.betType || '').toLowerCase();
        const searchText = pick + ' ' + betType;
        return !searchText.includes('tt') && !searchText.includes('team total');
    });

    if (gameTotalData.length > 0) {
        const gameStats = calculateStats(gameTotalData, true);
        row = document.createElement('tr');
        row.innerHTML = `
            <td><strong>Game Totals</strong></td>
            <td class="${gameStats.winRate > 50 ? 'win' : 'loss'}">${gameStats.record}</td>
            <td class="${gameStats.winRate > 50 ? 'win' : ''}">${gameStats.winRate.toFixed(1)}%</td>
            <td class="${gameStats.units >= 0 ? 'win' : 'loss'}">${gameStats.units >= 0 ? '+' : ''}${gameStats.units.toFixed(1)}u</td>
            <td class="${gameStats.roi >= 0 ? 'win' : 'loss'}">${gameStats.roi >= 0 ? '+' : ''}${gameStats.roi.toFixed(1)}%</td>
            <td>${findBestSport(gameTotalData)}</td>
        `;
        tbody.appendChild(row);
    }

    // First Half Totals
    const firstHalfData = totalBetsData.filter(row => {
        const pick = (row.Pick || row.pick || '').toLowerCase();
        const betType = (row['Bet Type'] || row['bet type'] || row.BetType || row.betType || '').toLowerCase();
        const searchText = pick + ' ' + betType;
        return searchText.includes('1h') || searchText.includes('first half') || searchText.includes('1st half');
    });

    if (firstHalfData.length > 0) {
        const fhStats = calculateStats(firstHalfData, true);
        row = document.createElement('tr');
        row.innerHTML = `
            <td><strong>First Half Totals</strong></td>
            <td class="${fhStats.winRate > 50 ? 'win' : 'loss'}">${fhStats.record}</td>
            <td class="${fhStats.winRate > 50 ? 'win' : ''}">${fhStats.winRate.toFixed(1)}%</td>
            <td class="${fhStats.units >= 0 ? 'win' : 'loss'}">${fhStats.units >= 0 ? '+' : ''}${fhStats.units.toFixed(1)}u</td>
            <td class="${fhStats.roi >= 0 ? 'win' : 'loss'}">${fhStats.roi >= 0 ? '+' : ''}${fhStats.roi.toFixed(1)}%</td>
            <td>${findBestSport(firstHalfData)}</td>
        `;
        tbody.appendChild(row);
    }
}

function calculateTeamTotalsBySport() {
    const sports = ['NFL', 'NBA', 'NHL', 'MLB', 'NCAAF', 'NCAAB', 'Soccer'];
    const tbody = document.getElementById('team-totals-by-sport');
    tbody.innerHTML = '';

    let hasData = false;

    sports.forEach(sport => {
        const sportData = allData.filter(row => {
            if (row.sport !== sport) return false;

            const pick = (row.Pick || row.pick || '').toLowerCase();
            const betType = (row['Bet Type'] || row['bet type'] || row.BetType || row.betType || '').toLowerCase();
            const searchText = pick + ' ' + betType;

            // Filter for team totals (only match "team total", not "tt" which catches Seattle, Pittsburgh, etc.)
            return searchText.includes('team total');
        });

        if (sportData.length === 0) return;

        hasData = true;
        const stats = calculateStats(sportData, true);
        const row = document.createElement('tr');
        row.innerHTML = `
            <td><span class="badge badge-${sport.toLowerCase()}">${sport}</span></td>
            <td class="${stats.winRate >= 50 ? 'win' : 'loss'}">${stats.record}</td>
            <td class="${stats.winRate >= 50 ? 'win' : 'loss'}">${stats.winRate.toFixed(1)}%</td>
            <td class="${stats.units >= 0 ? 'win' : 'loss'}">${stats.units >= 0 ? '+' : ''}${stats.units.toFixed(1)}u</td>
            <td class="${stats.roi >= 0 ? 'win' : 'loss'}">${stats.roi >= 0 ? '+' : ''}${stats.roi.toFixed(1)}%</td>
            <td>${stats.avgOdds > 0 ? '+' : ''}${stats.avgOdds}</td>
        `;
        tbody.appendChild(row);
    });

    if (!hasData) {
        tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--muted);">No team total data available</td></tr>';
    }
}

function createPerformanceChart() {
    const sports = ['NFL', 'NBA', 'NHL', 'MLB', 'NCAAF', 'NCAAB', 'Soccer'];
    const sportData = sports.map(sport => {
        const data = allData.filter(row => row.sport === sport);
        if (data.length === 0) return null;
        const stats = calculateStats(data);
        return {
            sport: sport,
            winRate: stats.winRate,
            units: stats.units,
            roi: stats.roi,
            record: stats.record
        };
    }).filter(item => item !== null);

    // Find max units for scaling (use absolute values)
    const maxUnits = Math.max(...sportData.map(d => Math.abs(d.units)), 10); // Minimum 10 for scaling
    const container = document.getElementById('unitsChart');
    container.innerHTML = '';

    sportData.forEach(sport => {
        const barHeight = (Math.abs(sport.units) / maxUnits) * 100;
        const isPositive = sport.units >= 0;

        const barHTML = `
            <div style="display: flex; flex-direction: column; align-items: center; flex: 1; min-width: 100px;">
                <div style="
                    font-family: 'Orbitron', sans-serif;
                    font-size: 26px;
                    font-weight: 900;
                    color: ${isPositive ? '#39FF14' : '#FF3131'};
                    margin-bottom: 10px;
                    text-shadow: 0 0 10px ${isPositive ? '#39FF14' : '#FF3131'};
                ">
                    ${sport.units >= 0 ? '+' : ''}${sport.units.toFixed(1)}u
                </div>
                <div style="
                    width: 80px;
                    height: ${barHeight}%;
                    min-height: 40px;
                    background: ${isPositive ? 'linear-gradient(180deg, #39FF14, #2ecc71)' : 'linear-gradient(180deg, #FF3131, #e74c3c)'};
                    border-radius: 10px 10px 0 0;
                    box-shadow: 0 0 30px ${isPositive ? 'rgba(57, 255, 20, 0.6)' : 'rgba(255, 49, 49, 0.6)'};
                    position: relative;
                    transition: all 0.5s ease;
                "></div>
                <div style="
                    font-family: 'Orbitron', sans-serif;
                    font-size: 22px;
                    font-weight: bold;
                    color: #00e0ff;
                    margin-top: 15px;
                    text-shadow: 0 0 8px #00e0ff;
                ">${sport.sport}</div>
                <div style="
                    font-size: 14px;
                    color: #888;
                    margin-top: 5px;
                    text-align: center;
                ">${sport.winRate.toFixed(1)}%</div>
            </div>
        `;

        container.innerHTML += barHTML;
    });
}

function extractOdds(line) {
    // Match all numbers with +/- signs, then take the last one (which is typically the odds)
    const matches = line.match(/([+-]\d+)/g);
    if (!matches || matches.length === 0) return null;

    // The odds are usually the last +/- number in the line
    const lastMatch = matches[matches.length - 1];
    return parseInt(lastMatch);
}

function extractBetSize(row) {
    // PARSE bet size DIRECTLY from Pick or Bet Type text (e.g., "1u", "2u", "0.5u")
    const pick = (row.Pick || row.pick || '').toLowerCase();
    const betType = (row['Bet Type'] || row['bet type'] || row.BetType || row.betType || '').toLowerCase();
    const confidence = (row.Confidence || row.confidence || '');
    const searchText = pick + ' ' + betType;

    // Look for patterns like "0.5u", "1u", "2u", "3u", etc.
    // More flexible regex - allows optional spaces between number and 'u'
    // Use negative lookahead (?!n) to avoid matching "un" in words like "under"
    const unitMatch = searchText.match(/(\d+\.?\d*)\s*u(?!n)/i);
    if (unitMatch) {
        const betSize = parseFloat(unitMatch[1]);
        if (!isNaN(betSize) && betSize > 0) {
            return betSize;
        }
    }

    // PRIMARY METHOD: Check confidence level (1-6 confidence maps to unit sizes)
    // This should be the PRIMARY method since most picks use confidence levels
    if (confidence) {
        const confNum = parseInt(confidence);
        if (!isNaN(confNum)) {
            // Map confidence to typical unit sizes
            const confMap = { 1: 0.5, 2: 1, 3: 1.5, 4: 2, 5: 2.5, 6: 3 };
            if (confMap[confNum]) {
                return confMap[confNum];
            }
        }
    }

    // Fallback: Try to extract from Units column
    // For wins: Units column shows profit (need to reverse-calculate stake from odds)
    // For losses: Units column shows negative amount risked
    const result = (row.Result || row.result || '').toUpperCase();
    const units = parseFloat(row.Units || row.units || 0);
    const line = row.Line || row.line || row.Odds || row.odds || '';

    if ((result === 'L' || result === 'LOSS') && !isNaN(units) && units < 0) {
        // For losses, the Units column is the negative amount risked
        return Math.abs(units);
    }

    if ((result === 'W' || result === 'WIN') && !isNaN(units) && units > 0) {
        // For wins, try to reverse-calculate stake from profit and odds
        const odds = extractOdds(line);
        if (odds) {
            // For positive odds: profit = stake * (odds/100)
            // For negative odds: profit = stake * (100/|odds|)
            if (odds > 0) {
                const stake = units / (odds / 100);
                if (stake > 0 && stake < 10) return Math.round(stake * 2) / 2; // Round to nearest 0.5
            } else if (odds < 0) {
                const stake = units / (100 / Math.abs(odds));
                if (stake > 0 && stake < 10) return Math.round(stake * 2) / 2; // Round to nearest 0.5
            }
        }
    }

    // Final fallback: default to 1u
    return 1;
}

async function init() {
    try {
        await fetchAllData();

        // TRIAGE REPORT: DATA SOURCE AND COLUMN MAPPING
        console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
        console.log('‚ïë           CONFIDENCE LEVEL TABLE TRIAGE REPORT                  ‚ïë');
        console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
        console.log('');
        console.log('1. SOURCE OF TRUTH');
        console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
        console.log('Data Sources:');
        console.log('  ‚Ä¢ NFL: Google Sheets CSV export');
        console.log('  ‚Ä¢ NBA: Google Sheets CSV export');
        console.log('  ‚Ä¢ NHL: Google Sheets CSV export');
        console.log('  ‚Ä¢ MLB: Google Sheets CSV export');
        console.log('  ‚Ä¢ NCAAF: Google Sheets CSV export');
        console.log('  ‚Ä¢ NCAAB: Google Sheets CSV export');
        console.log('  ‚Ä¢ Soccer: Google Sheets CSV export');
        console.log('');

        // Analyze column structure from first row
        if (allData.length > 0) {
            const firstRow = allData[0];
            console.log('Column Mapping (case-insensitive):');
            const columns = Object.keys(firstRow);
            columns.forEach(col => {
                const val = firstRow[col];
                const display = typeof val === 'string' && val.length > 50 ? val.substring(0, 50) + '...' : val;
                console.log(`  ‚Ä¢ ${col}: ${display}`);
            });
        }
        console.log('');
        console.log('Key Column Access Patterns:');
        console.log('  ‚Ä¢ Confidence: row.Confidence || row.confidence');
        console.log('  ‚Ä¢ Result: row.Result || row.result');
        console.log('  ‚Ä¢ Units: row.Units || row.units');
        console.log('  ‚Ä¢ Pick: row.Pick || row.pick');
        console.log('  ‚Ä¢ Bet Type: row["Bet Type"] || row.BetType || row["bet type"] || row.betType');
        console.log('  ‚Ä¢ Line: row.Line || row.line');
        console.log('');

        // DEBUG: Show first 10 bets with all relevant columns
        console.log('2. SAMPLE DATA (First 10 graded bets)');
        console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
        const gradedBets = allData.filter(row => {
            const result = (row.Result || row.result || '').toLowerCase();
            return result && result !== '' && result !== 'pending';
        });

        gradedBets.slice(0, 10).forEach((row, i) => {
            const betSize = extractBetSize(row);
            console.log(`Bet #${i+1}:`, {
                Sport: row.sport,
                Pick: (row.Pick || row.pick || '').substring(0, 35),
                Confidence: row.Confidence || row.confidence || 'MISSING',
                Result: row.Result || row.result,
                Units: row.Units || row.units,
                ExtractedBetSize: betSize + 'u'
            });
        });
        console.log(`Total graded bets: ${gradedBets.length}`);
        console.log('=================================');

        // AVG ODDS VERIFICATION - Log detailed breakdown before rendering
        console.log('=== AVG ODDS CALCULATION VERIFICATION ===');
        const sports = ['NFL', 'NBA', 'NHL', 'MLB', 'NCAAF', 'NCAAB', 'Soccer'];
        sports.forEach(sport => {
            const sportData = allData.filter(row => row.sport === sport);
            if (sportData.length === 0) return;

            // Manual calculation for verification
            let oddsSum = 0, oddsCount = 0, excludedCount = 0, pushCount = 0;
            const sampleOdds = [];

            sportData.forEach(row => {
                const result = (row.Result || row.result || '').toUpperCase();
                const line = row.Line || row.line || row.Odds || row.odds || '';
                const pick = (row.Pick || row.pick || '').toLowerCase();
                const betType = (row['Bet Type'] || row['bet type'] || row.BetType || row.betType || '').toLowerCase();
                const searchText = pick + ' ' + betType;

                // Skip pending
                if (!result || result === 'PENDING') return;

                // Track pushes but INCLUDE them in average
                if (result === 'P' || result === 'PUSH') {
                    pushCount++;
                }

                // Check for parlay/teaser
                const isParlay = searchText.includes('parlay');
                const isTeaser = searchText.includes('teaser');

                if (isParlay || isTeaser) {
                    excludedCount++;
                    return;
                }

                const odds = extractOdds(line);
                if (odds) {
                    oddsSum += odds;
                    oddsCount++;
                    if (sampleOdds.length < 5) {
                        sampleOdds.push(`${odds} (${pick.substring(0, 25)}...)`);
                    }
                }
            });

            const avgOdds = oddsCount > 0 ? Math.round(oddsSum / oddsCount) : -110;
            console.log(`${sport}:`);
            console.log(`  Total bets: ${sportData.length}`);
            console.log(`  Included in avg: ${oddsCount}`);
            console.log(`  Excluded (parlays/teasers): ${excludedCount}`);
            console.log(`  Pushes (INCLUDED in avg): ${pushCount}`);
            console.log(`  Avg Odds: ${avgOdds}`);
            console.log(`  Sample odds: ${sampleOdds.join(', ')}`);
            console.log(`  Formula: Sum(${oddsSum}) / Count(${oddsCount}) = ${avgOdds}`);
        });
        console.log('==========================================\n');

        calculateOverallStats();
        calculateSportBreakdown();
        calculateBetTypeBreakdown();
        calculateMonthlyBreakdown();
        calculateUnitSizingBreakdown();
        calculateTeaserBreakdown();
        calculateParlayBreakdown();
        calculateFiveInningBreakdown();
        calculateTotalBetsBreakdown();
        calculateTeamTotalsBySport();

        // COMPREHENSIVE MATH VERIFICATION
        console.log('=== MATH VERIFICATION ===');

        // Overall stats
        const overallStats = calculateStats(allData, true);
        console.log(`Overall Record: ${overallStats.record}, Units: ${overallStats.units.toFixed(1)}u, Total Risked: ${overallStats.totalRisked.toFixed(1)}u, ROI: ${overallStats.roi.toFixed(1)}%`);

        // Sport breakdown verification
        let sportTotalWins = 0, sportTotalLosses = 0, sportTotalPushes = 0, sportTotalUnits = 0;
        sports.forEach(sport => {
            const sportData = allData.filter(row => row.sport === sport);
            if (sportData.length > 0) {
                const stats = calculateStats(sportData, true);
                sportTotalWins += stats.wins;
                sportTotalLosses += stats.losses;
                sportTotalPushes += stats.pushes;
                sportTotalUnits += stats.units;
            }
        });
        console.log(`Sport Breakdown Total: ${sportTotalWins}-${sportTotalLosses}-${sportTotalPushes}, Units: ${sportTotalUnits.toFixed(1)}u`);
        console.log(`Match Overall: ${sportTotalWins === overallStats.wins && sportTotalLosses === overallStats.losses && sportTotalPushes === overallStats.pushes ? '‚úì YES' : '‚úó NO'}`);

        // Unit sizing verification
        const confidenceLevels = [
            { name: 'MAX PLAY', min: 3, max: Infinity },
            { name: 'HIGH', min: 2, max: 3 },
            { name: 'STANDARD', min: 1, max: 2 },
            { name: 'SMALL', min: 0, max: 1 }
        ];
        let unitSizingTotalWins = 0, unitSizingTotalLosses = 0, unitSizingTotalPushes = 0, unitSizingTotalCount = 0;
        confidenceLevels.forEach(level => {
            const levelData = allData.filter(row => {
                const result = (row.Result || row.result || '').toLowerCase();
                if (!result || result === '' || result === 'pending') return false;
                const betSize = extractBetSize(row);
                return betSize >= level.min && (level.max === Infinity ? true : betSize < level.max);
            });
            if (levelData.length > 0) {
                const stats = calculateStats(levelData, true);
                unitSizingTotalWins += stats.wins;
                unitSizingTotalLosses += stats.losses;
                unitSizingTotalPushes += stats.pushes;
                unitSizingTotalCount += levelData.length;
                console.log(`  ${level.name}: ${stats.wins}-${stats.losses}-${stats.pushes} (${levelData.length} bets)`);
            }
        });
        console.log(`Unit Sizing Total: ${unitSizingTotalWins}-${unitSizingTotalLosses}-${unitSizingTotalPushes} (${unitSizingTotalCount} bets)`);
        console.log(`Match Overall: ${unitSizingTotalWins === overallStats.wins && unitSizingTotalLosses === overallStats.losses ? '‚úì YES' : '‚úó NO'}`);

        console.log('=========================');

        document.getElementById('loading-screen').style.display = 'none';
        document.getElementById('main-content').style.display = 'block';

        const now = new Date();
        document.getElementById('load-time').textContent = now.toLocaleString();
    } catch (error) {
        console.error('Error initializing dashboard:', error);
        document.getElementById('loading-screen').innerHTML = '<p style="color: var(--red);">Error loading data. Please refresh the page.</p>';
    }
}

document.addEventListener('DOMContentLoaded', init);

// Mobile dropdown menu functionality
document.addEventListener('DOMContentLoaded', function() {
    const dropdowns = document.querySelectorAll('.dropdown');
        dropdowns.forEach(dropdown => {
        const dropbtn = dropdown.querySelector('.dropbtn');
        const dropdownContent = dropdown.querySelector('.dropdown-content');

        if (dropbtn && dropdownContent) {
            // Handle button clicks to toggle dropdown
            dropbtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();

                // Close all other dropdowns
                dropdowns.forEach(otherDropdown => {
                    if (otherDropdown !== dropdown) {
                        otherDropdown.classList.remove('active');
                    }
                });

                // Toggle current dropdown
                dropdown.classList.toggle('active');
            });


        }
    });

    // Close dropdowns when clicking outside
    document.addEventListener('click', function(e) {
        // Check if click is outside all dropdowns
        if (!e.target.closest('.dropdown')) {
            dropdowns.forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
    });
});
    </script>


<!-- Clicky Analytics -->
<a title="Web Analytics" href="https://clicky.com/101485054"><img alt="Clicky" src="//static.getclicky.com/media/links/badge.gif" border="0" /></a>
<script async data-id="101485054" src="//static.getclicky.com/js"></script>
</body>
</html>
<!-- Force rebuild Mon, Oct 27, 2025  4:13:41 PM -->
